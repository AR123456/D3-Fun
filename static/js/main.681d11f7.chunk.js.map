{"version":3,"sources":["useResizeObserver.js","TreeChart.js","App.js","serviceWorker.js","index.js"],"names":["useResizeObserver","ref","useState","dimensions","setDimensions","useEffect","observeTarget","current","resizeObserver","ResizeObserver","entries","forEach","entry","contentRect","observe","unobserve","TreeChart","data","svgRef","useRef","wrapperRef","previouslyRenderedData","value","usePrevious","svg","select","getBoundingClientRect","width","height","root","hierarchy","treeLayout","tree","size","linkGenerator","linkHorizontal","x","link","y","console","warn","descendants","links","selectAll","join","enter","append","attr","node","transition","duration","delay","depth","enteringAndUpdatingLinks","length","this","getTotalLength","source","text","name","style","marginBottom","initialData","children","App","setData","Fragment","onClick","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.681d11f7.chunk.js","sourcesContent":["import { useEffect, useState } from \"react\";\nimport ResizeObserver from \"resize-observer-polyfill\";\n\nconst useResizeObserver = ref => {\n  const [dimensions, setDimensions] = useState(null);\n  useEffect(() => {\n    const observeTarget = ref.current;\n    const resizeObserver = new ResizeObserver(entries => {\n      entries.forEach(entry => {\n        setDimensions(entry.contentRect);\n      });\n    });\n    resizeObserver.observe(observeTarget);\n    return () => {\n      resizeObserver.unobserve(observeTarget);\n    };\n  }, [ref]);\n  return dimensions;\n};\n\nexport default useResizeObserver;\n","import React, { useRef, useEffect } from \"react\";\r\nimport { select, hierarchy, tree, linkHorizontal } from \"d3\";\r\nimport useResizeObserver from \"./useResizeObserver\";\r\n\r\nfunction usePrevious(value) {\r\n  const ref = useRef();\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  });\r\n  return ref.current;\r\n}\r\n\r\nfunction TreeChart({ data }) {\r\n  const svgRef = useRef();\r\n  const wrapperRef = useRef();\r\n  const dimensions = useResizeObserver(wrapperRef);\r\n\r\n  // we save data to see if it changed\r\n  const previouslyRenderedData = usePrevious(data);\r\n\r\n  // will be called initially and on every data change\r\n  useEffect(() => {\r\n    const svg = select(svgRef.current);\r\n\r\n    // use dimensions from useResizeObserver,\r\n    // but use getBoundingClientRect on initial render\r\n    // (dimensions are null for the first render)\r\n    const { width, height } =\r\n      dimensions || wrapperRef.current.getBoundingClientRect();\r\n\r\n    // transform hierarchical data\r\n    const root = hierarchy(data);\r\n    const treeLayout = tree().size([height, width]);\r\n\r\n    const linkGenerator = linkHorizontal()\r\n      .x(link => link.y)\r\n      .y(link => link.x);\r\n\r\n    // enrich hierarchical data with coordinates\r\n    treeLayout(root);\r\n\r\n    console.warn(\"descendants\", root.descendants());\r\n    console.warn(\"links\", root.links());\r\n\r\n    // nodes\r\n    svg\r\n      .selectAll(\".node\")\r\n      .data(root.descendants())\r\n      .join(enter => enter.append(\"circle\").attr(\"opacity\", 0))\r\n      .attr(\"class\", \"node\")\r\n      .attr(\"cx\", node => node.y)\r\n      .attr(\"cy\", node => node.x)\r\n      .attr(\"r\", 4)\r\n      .transition()\r\n      .duration(500)\r\n      .delay(node => node.depth * 300)\r\n      .attr(\"opacity\", 1);\r\n\r\n    // links\r\n    const enteringAndUpdatingLinks = svg\r\n      .selectAll(\".link\")\r\n      .data(root.links())\r\n      .join(\"path\")\r\n      .attr(\"class\", \"link\")\r\n      .attr(\"d\", linkGenerator)\r\n      .attr(\"stroke-dasharray\", function() {\r\n        const length = this.getTotalLength();\r\n        return `${length} ${length}`;\r\n      })\r\n      .attr(\"stroke\", \"black\")\r\n      .attr(\"fill\", \"none\")\r\n      .attr(\"opacity\", 1);\r\n\r\n    if (data !== previouslyRenderedData) {\r\n      enteringAndUpdatingLinks\r\n        .attr(\"stroke-dashoffset\", function() {\r\n          return this.getTotalLength();\r\n        })\r\n        .transition()\r\n        .duration(500)\r\n        .delay(link => link.source.depth * 500)\r\n        .attr(\"stroke-dashoffset\", 0);\r\n    }\r\n\r\n    // labels\r\n    svg\r\n      .selectAll(\".label\")\r\n      .data(root.descendants())\r\n      .join(enter => enter.append(\"text\").attr(\"opacity\", 0))\r\n      .attr(\"class\", \"label\")\r\n      .attr(\"x\", node => node.y)\r\n      .attr(\"y\", node => node.x - 12)\r\n      .attr(\"text-anchor\", \"middle\")\r\n      .attr(\"font-size\", 24)\r\n      .text(node => node.data.name)\r\n      .transition()\r\n      .duration(500)\r\n      .delay(node => node.depth * 300)\r\n      .attr(\"opacity\", 1);\r\n  }, [data, dimensions, previouslyRenderedData]);\r\n\r\n  return (\r\n    <div ref={wrapperRef} style={{ marginBottom: \"2rem\" }}>\r\n      <svg ref={svgRef}></svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default TreeChart;\r\n","import React, { useState } from \"react\";\nimport TreeChart from \"./TreeChart\";\nimport \"./App.css\";\n\nconst initialData = {\n  name: \"😐\",\n  children: [\n    {\n      name: \"🙂\",\n      children: [\n        {\n          name: \"😀\"\n        },\n        {\n          name: \"😁\"\n        },\n        {\n          name: \"🤣\"\n        }\n      ]\n    },\n    {\n      name: \"😔\"\n    }\n  ]\n};\n\nfunction App() {\n  const [data, setData] = useState(initialData);\n\n  return (\n    <React.Fragment>\n      <h1>Animated Tree Chart</h1>\n      <TreeChart data={data} />\n      <button onClick={() => setData(initialData.children[0])}>\n        Update data\n      </button>\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}